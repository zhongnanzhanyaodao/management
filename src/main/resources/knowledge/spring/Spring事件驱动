事件驱动模型简介

事件驱动模型也就是我们常说的观察者，或者发布-订阅模型；理解它的几个关键点：

    首先是一种对象间的一对多的关系；最简单的如交通信号灯，信号灯是目标（一方），行人注视着信号灯（多方）；
    当目标发送改变（发布），观察者（订阅者）就可以接收到改变；
    观察者如何处理（如行人如何走，是快走/慢走/不走，目标不会管的），目标无需干涉；所以就松散耦合了它们之间的关系。


接下来先看一个用户注册的例子，如图： spring事件驱动用户注册.1.jpg

用户注册成功后，需要做这么多事：

1、加积分
2、发确认邮件
3、如果是游戏帐户，可能赠送游戏大礼包
4、索引用户数据
…………

问题：

    UserService和其他Service耦合严重，增删功能比较麻烦；
    有些功能可能需要调用第三方系统，如增加积分/索引用户，速度可能比较慢，此时需要异步支持；这个如果使用Spring，可以轻松解决，后边再介绍；


从如上例子可以看出，应该使用一个观察者来解耦这些Service之间的依赖关系，如图：spring事件驱动用户注册.2.jpg

增加了一个Listener来解耦UserService和其他服务，即注册成功后，只需要通知相关的监听器，不需要关系它们如何处理。增删功能非常容易。
这就是一个典型的事件处理模型/观察者，解耦目标对象和它的依赖对象，目标只需要通知它的依赖对象，具体怎么处理，依赖对象自己决定。比如是异步还是同步，延迟还是非延迟等。
上边其实也使用了DIP（依赖倒置原则），依赖于抽象，而不是具体。
还有就是使用了IoC思想，即以前主动去创建它依赖的Service，现在只是被动等待别人注册进来。

其他的例子还有如GUI中的按钮和动作的关系，按钮和动作本身都是一种抽象，每个不同的按钮的动作可能不一样；如“文件-->新建”打开新建窗口；点击“关闭”按钮关闭窗口等等。
主要目的是：松散耦合对象间的一对多的依赖关系，如按钮和动作的关系；

如何实现呢？面向接口编程（即面向抽象编程），而非面向实现。即按钮和动作可以定义为接口，这样它俩的依赖是最小的（如在Java中，没有比接口更抽象的了）。

有朋友会问，我刚开始学的时候也是这样：抽象类不也行吗？
记住一个原则：接口目的是抽象，抽象类目的是复用；
所以如果接触过servlet/struts2/spring等框架，大家都应该知道：

    Servlet<-----GenericServlet<-----HttpServlet<------我们自己的
    Action<------ActionSupport<------我们自己的
    DaoInterface<------××DaoSupport<-----我们自己的

从上边大家应该能体会出接口、抽象类的主要目的了。现在想想其实很简单。

在Java中接口还一个非常重要的好处：接口是可以多实现的，类/抽象类只能单继承，所以使用接口可以非常容易扩展新功能（还可以实现所谓的mixin），类/抽象类办不到。


出自：http://jinnianshilongnian.iteye.com/blog/1902886

学习感悟：
交通信号灯场景
使用了DIP（依赖倒置原则），依赖于抽象，而不是具体。
使用了IoC思想，即以前主动去创建它依赖的Service，现在只是被动等待别人注册进来。
面向接口编程（即面向抽象编程），而非面向实现。
接口目的是抽象，抽象类目的是复用
