Java适配器模式

定义
简单理解就是适配器模式可以将一个对象进行包装，使得该对象与其他类兼容。

Code

有一个快艇接口SpeedBoat

/**
 * 快艇
 */
public interface SpeedBoat {
    void speed();
}

有个船长，他只会开快艇

/**
 * 船长
 */
public class Captain implements SpeedBoat {
    SpeedBoat speedBoat;
    public Captain(SpeedBoat speedBoat) {
        this.speedBoat = speedBoat;
    }
    @Override
    public void speed() {
        speedBoat.speed();
    }
}

有一天船长惹事被人追着砍，准备跑路，刚好看到一艘国产快艇

/**
 * 国产快艇
 */
public class ChinaSpeedBoat implements SpeedBoat {
    @Override
    public void speed() {
        System.out.println("船长开中国快艇");
    }
}

于是一顿操作

public class Main {
    public static void main(String[] args) {
        Captain captain1 = new Captain(new ChinaSpeedBoat());
        captain1.speed();
    }
}
打印：船长开中国快艇

跑路成功没毛病，这天船长又惹事被人追着砍，准备跑路，结果附近只有一艘渔船

/**
 * 渔船
 */
public class FishingBoat {
    public void fishing() {
        System.out.print("船长开渔船");
    }
}

为了不被砍，船长可以管渔船叫爹(extends FishingBoat)，这样他就有开渔船的功能了，但是显然这很不符合逻辑，况且下次如果被砍的时候遇到的是冲锋艇或者航母，还是不能解决问题，因此需要创建一个适配器，让船长用开快艇的技能来开渔船


public class FinishingBoatAdapter implements SpeedBoat {
    private FishingBoat boat;
    public FinishingBoatAdapter() {
        boat = new FishingBoat();
    }
    @Override
    public void speed() {
        boat.fishing();
    }
}

一顿操作

public class Main {
    public static void main(String[] args) {
        Captain captain2 = new Captain(new FinishingBoatAdapter());
        captain2.speed();
    }
}
打印：船长开渔船

不管下次遇到什么船，用适配器的方法都能跑路成功。